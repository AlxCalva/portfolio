1. Arreglos

* * *

## Listas (Python list)

Para su facilidad de uso, python cuenta con diversos tipos de estructuras de listado de datos, usualmente conocidas como arreglos.

```
L = list(range(10))
L

```

> \[0, 1, 2, 3, 4, 5, 6, 7, 8, 9\]

Una lista es un arreglo dinámico de cualquier tipode datos. Puede incluir enteros, caracteres o incluso datos mixtos.

```
L2 = [True, "2", 3, 4.0]
[type(item) for item in L3]

```

> \[bool, str, int, float\]

Mas esta flexibilidad es demasiado costosa. Cada elemento de la lista es en sí un struct, ya que incluso fuera de cualquiér lista, un entero en python es en realidad un struct en c disfrazado de int, ahora en esta lista, cada elemento guarda datos de diversa índole, como su espacio en memoria, su dirección de memoria, su tipo de objeto, etcétera.  
Muchos de estos datos se hacen redundantes cuando trabajamos con un arreglo del mismo tipo de datos.

* * *

## Arreglos de tipos fijos

Los arreglos de tipo de dato fijo, pese a ser menos flexibles son más ágiles y prácticos en el manejo y análisis de datasets.

### Array

Existe el tipo de dato "array", que para utilizarse, requiere de importar su librería

```
import array
L = list(range(10))
A = array.array('i', L)
A
```

> array('i', \[0, 1, 2, 3, 4, 5, 6, 7, 8, 9\])

La primer letra que se observa en el array indica el tipo de dato.


### NumPy NdArray

El arreglo de python ofrece eficiencia en el almacenamiento de datos, pero el arreglo de numpy ofrece además de eso, una serie de operaciones muy interesantes, que serán vistas más adelante. De momento, veremos cómo declarar los arreglos de numpy.

```
import numpy as np
A = np.array([1,2,3,4])

```

Si se introducen diferentes tipos de dato, numpy intentará hacer un upcast (si le es posible), dado que sólo aceptará variables del mismo tipode dato

`np.array([3.14, 1.4, 0, 1])`

> np.array(\[3.14, 1.4, 0.0, 1.0\])

Si queremos establecer explícitamente el tipo de dato, podemos utilizar la palabra reservada `dtype`
`np.array([1.5, 1, 1.7, 1.2, 1.0],dtype=int)`
>array([1, 1, 1, 1, 1])

A diferencia de las listas, los arreglos de numpy pueden ser multidimensionales
`np.array([range(i,i+3) for i in [1,5,9]])`
>array([[ 1,  2,  3],
       [ 5,  6,  7],
       [ 9, 10, 11]])

#### Rutinas para crear arreglos
Cuando es necesario generar arreglos más grandes, algunas rutinas pueden ser útiles

Crear matrices de ceros
`np.zeros(10,dtype=int)`
>array([0,0,0,0,0,0,0,0,0,0])

Crear matrices de unos con tipo float
`np.ones((3,3),dtype=float)`
>array([[1., 1., 1.],
>			[1., 1., 1.],
>			[1., 1., 1.]])

Crear un arreglo 4x4 lleno con 3.14
`np.full((4,4), 3.14)`
>array([[3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14],
       [3.14, 3.14, 3.14, 3.14]])

Mucho paiton


id: 0cb45b3e2b814e6cb93e80a999a23189
parent_id: 5d90860aac0b47e18b3043a1f57871ea
created_time: 2025-08-18T03:30:55.963Z
updated_time: 2025-08-19T04:47:03.176Z
is_conflict: 0
latitude: 19.39949340
longitude: -98.98966430
altitude: 0.0000
author: 
source_url: 
is_todo: 0
todo_due: 0
todo_completed: 0
source: joplin-desktop
source_application: net.cozic.joplin-desktop
application_data: 
order: 0
user_created_time: 2025-08-18T03:30:55.963Z
user_updated_time: 2025-08-19T04:47:03.176Z
encryption_cipher_text: 
encryption_applied: 0
markup_language: 1
is_shared: 0
share_id: 
conflict_original_id: 
master_key_id: 
user_data: 
deleted_time: 0
type_: 1