id: 8b01c1dcfab54207a07a415284a77ee9
parent_id: 76e36e94227f4f609a5fe85018c2ada0
item_type: 1
item_id: 0cb45b3e2b814e6cb93e80a999a23189
item_updated_time: 1755575795235
title_diff: "[]"
body_diff: "[{\"diffs\":[[1,\"* * *\\\n\\\n## Listas (Python list)\\\n\\\n\"],[0,\"Para su \"]],\"start1\":0,\"start2\":0,\"length1\":8,\"length2\":40},{\"diffs\":[[0,\"o arreglos.\\\n\"],[1,\"\\\n\"],[0,\"```\\\nL = list\"]],\"start1\":151,\"start2\":151,\"length1\":24,\"length2\":25},{\"diffs\":[[0,\")\\\nL\\\n\"],[-1,\">\"],[1,\"\\\n```\\\n\\\n\"],[0,\"> \"],[1,\"\\\\\"],[0,\"[0, \"]],\"start1\":186,\"start2\":186,\"length1\":11,\"length2\":17},{\"diffs\":[[0,\" 7, 8, 9\"],[1,\"\\\\\"],[0,\"]\\\n\"],[-1,\"```\"],[0,\"\\\nUna lis\"]],\"start1\":220,\"start2\":220,\"length1\":21,\"length2\":19},{\"diffs\":[[0,\"mixtos.\\\n\"],[1,\"\\\n\"],[0,\"```\\\nL2 =\"]],\"start1\":342,\"start2\":342,\"length1\":16,\"length2\":17},{\"diffs\":[[0,\"L3]\\\n\"],[-1,\">>\"],[1,\"\\\n```\\\n\\\n > \\\\\"],[0,\"[boo\"]],\"start1\":404,\"start2\":404,\"length1\":10,\"length2\":18},{\"diffs\":[[0,\"loat\"],[1,\"\\\\\"],[0,\"]\"],[-1,\"\\\n```\"],[0,\"\\\n\\\nMa\"]],\"start1\":436,\"start2\":436,\"length1\":13,\"length2\":10},{\"diffs\":[[0,\"ta lista, ca\"],[1,\"da elemento guarda datos de diversa índole, como su espacio en memoria, su dirección de memoria, su tipo de objeto, etcétera.  \\\nMuchos de estos datos se hacen redundantes cuando trabajamos con un arreglo del mismo tipo de datos.\\\n\\\n* * *\\\n\\\n## Arreglos de tipos fijos\\\n\\\nLos arreglos de tipo de dato fijo, pese a ser menos flexibles son más ágiles y prácticos en el manejo y análisis de datasets.\\\n\\\n### Array\\\n\\\nExiste el tipo de dato \\\"array\\\", que para utilizarse, requiere de importar su librería\\\n\\\n```\\\nimport array\\\nL = list(range(10))\\\nA = array.array('i', L)\\\nA\\\n```\\\n\\\n> array('i', [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\\\n\\\nLa primer letra que se observa en el array indica el tipo de dato. \\\n***\\\n### NumPy NdArray\\\nEl arreglo de python ofrece eficiencia en el almacenamiento de datos, pero el arreglo de numpy ofrece además de eso, una serie de operaciones muy interesantes, que serán vistas más adelante. De momento, veremos cómo declarar los arreglos de numpy.\\\n\\\nimport numpy as np\\\nA = np.array([1,2,3,4])\\\n\\\nSi se introducen diferentes tipos de dato, numpy intentará hacer un upcast (si le es posible)\\\n\\\n = np.array([3.14, 1.4, 0, 1])\\\n> np.array([3.14, 1.4, 0.0, 1.0])\\\n\\\n\\\n\"]],\"start1\":655,\"start2\":655,\"length1\":12,\"length2\":1161}]"
metadata_diff: {"new":{},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2025-08-19T03:56:35.604Z
created_time: 2025-08-19T03:56:35.604Z
type_: 13